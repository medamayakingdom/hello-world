---
layout: page
title: "ソフトウェア工学　2025"
permalink: /docs/softwareEng2025
---

### 第1回 ガイダンス (2025年4月16日)
*   ソフトウェア工学の講義では、ソフトウェア・エンジニアリングの基礎と実務的なスキルの習得が目標とされている。
*   ソフトウェア工学概論、プロジェクトマネジメント、WBS,
    ソフトウェア開発プロセス、コーディング、UML、バージョン管理などを学習する。
    ソフトウェア工学の難しいところ
        実務から体系化された知見であるため、ソフトウェア開発経験がないとイメージが湧きにくい点。
        知見を理解しても実践することが難しい、知見と実践の乖離がある点。
        個々人の知識だけでは不十分であり、チーム全体で共有する必要がある点。
    堤田先生の個人的経験
        非情報学分野からITエンジニアへの転身をし、定期的なシステム更改対応、FOSS4G（Free Open Source Software for Geospatial）の活動、Individual ContributorとしてのRパッケージ開発、Deep Learningモデルのパラメータ調整、AI Agentによるソフトウェア開発などを経験。特にAI Agentによるソフトウェア開発では、要件定義、バージョン管理、テストが不可欠で、監督者としての能力（ソフトウェア工学にて学ぶ内容）が求められる。


### 第2回 ソフトウェア工学概論 (2025年4月23日)
*   ソフトウェアの定義
        1. 実行されることによって必要な特性、機能、性能を提供する命令語群（コンピュータプログラム）。
        2. プログラムが適切に情報を扱うことを可能とするデータ構造。
        3. プログラムの操作や使用法を記述した情報。
    これらは「情報」を扱うプロダクトそのものまたは、プロダクトを提供する手段とされている。
*   ソフトウェアの特徴
        ハードウェアと異なり劣化はしないが悪化はする。これは、新しい環境や技術のニーズへの適応、新しいビジネスを実現するための強化など、進化し続ける環境での再構築が必要となるため。
*   ソフトウェア工学のゴール
        「ソフトウェアシステムが変化し続ける状況に対応する方法論を考え出すこと」であり、新しいソフトウェアが古いシステムから構築され、すべてが互換性を持ち、他システムと相互運用する必要がある。
*   ソフトウェア工学の定義（IEEE）
        「ソフトウェアの開発、運用、メンテナンスに対するシステマティックで規律ある、定量化できるアプローチの適用」と定義されている。
     プラクティスの本質（how to solve it）
        1.  問題を理解する（コミュニケーションと分析）。
        2.  解決策を計画する（モデリングとソフトウェア設計）。
        3.  計画を実行に移す（コード実装）。
        4.  結果が正しいことを理解する（テストと品質保証）。
*   Hookerの7原則
        1.  システムが存在する唯一の理由
            システムはユーザーに価値を提供するためにある。
        2.  シンプルにしておけ！（KISS: Keep It Simple, Stupid!）
            すべての設計は可能な限りシンプルであるべき。
        3.  ビジョンを持ち続けよ
            ソフトウェアプロジェクトの成功には明確なビジョンが不可欠である。
        4.  あなたの作ったものを他の人が使用する
            他人が理解できるように仕様を決め、設計し、ドキュメントを書き、実装するべき。
        5.  未来へオープンであれ
            コンピュータ環境の仕様変更に対応できるよう準備しておく。
        6.  再利用に先駆けて計画せよ
            コストを低減し、再利用するコンポーネントとそれを取り込むシステムの両方の価値を高める。
        7.  考えよ！
            行動を起こす前に考えをもつことは、必ずといってよいほどよい結果を生む。
*   ソフトウェア工学
        「品質」「コスト」「納期」のバランスを実現するための手法・方法論。
*   ソフトウェア工学の必要性
        1. 　大規模化と複雑さ
            ソフトウェアなしでは社会が回らないため、効率的な開発とメンテナンス、効率と品質の両立が求められる。
        2.  IT人材の不足
            IT人材が不足している中、課題解決型＋価値創造型人材、スペシャリスト、プロジェクトマネジメント人材が求められている。
        3.  社会性と求められるミッション
            ライフライン・インフラストラクチャーとしてのソフトウェアが増加しており、不測の事態に対応した事業・サービスの継続が求められる。
        4.  不確実性の増大
            ソフトウェア利用の変化・多様化に対応した開発が必要。
            

### 第3回 ソフトウェアライフサイクル (2025年4月30日)
*   ソフトウェアの誕生
        ニーズの発生、ビジネス上・システム上の要求を具現化するための企画・計画、要件定義書の作成（どんなソフトウェアが必要か、業務がどう変わるか）。
    *   ソフトウェアの開発・運用
            ソフトウェアの開発、実稼働、保守運用。
    *   ソフトウェアの廃止
            サービスの終了、新規ソフトウェアへのリニューアル。
*   要件定義
        システムの目的や概要、機能、構成、性能目標、他システムとの連携仕様、運用上の注意点、制限や拡張性、開発スケジュール、体制、納品物などを網羅的にまとめる必要がある。実現する機能・しない機能を明確化し、実現性評価を行うことで機能の取捨選択やスケジュール調整、代替案検討に役立てる。多くの企業では、漏れを防ぐために要件定義項目をテンプレート化している。
*   設計
        要件定義書から設計書へ落とし込み、コーディングができるレベルの仕様書（クラス、モジュールなど）にする。WBSもこの段階で関連します。
*   制作（開発）
        設計書に従ってシステムを構築。内製（自社開発）と調達（外部委託）がある。
*   オフショア開発
        賃金の安い（安かった）海外企業に外部委託する手法。将来的には日本がオフショア開発される側になる可能性も指摘されている。
*   テスト・デバッグ
        すべてをテストすることは不可能（工数に限界）なため、どの箇所をどの程度テストするかが重要。
*   運用・保守
        稼働後のデータをプロアクティブに活用し、ソフトウェア以外の要因も考慮する必要がある。
*   ドキュメンテーション
        複数人でのソフトウェア開発では非同期コミュニケーション。海外企業とのプロジェクトが増える可能性があるため、英語のマニュアルやエラーメッセージへの対応も必要。

### 第4回 プロジェクト (2025年5月7日)
*   プロジェクトの性質
    *   有期性
            必ず終わりがある仕事であり、ルーティンワークとは異なる。
    *   独自性
            独自の目的を達成する仕事で、ソフトウェア開発が例として挙げられする
    *   フォアキャスティング
            今の立ち位置から順に目標に進んでいくアプローチで、目標に到達できない、または遠いところに到達する可能性がある。
    *   バックキャスティング
            定めた目標に向けて何が必要かを計画し達成に向かうアプローチで、目標を明確に設定する必要がある。目標と筋道は適宜修正可能であることが多い。
*   ソフトウェア分析
        ソフトウェアを見える化するための手法で、物量、実行性能、開発工数、品質に関する分析がある。これらは品質（Quality）、コスト（Cost）、納期（Delivery）のQCDに使用される。
*   ソフトウェアの評価
        ソフトウェアの価値を測るための指標です。
            1.  コードの物量（ステップ数）
                ソースコードの行数で評価する。
            2.  コードの物量（オブジェクト容量）
                組み込み型ソフトウェアではサイズが小さいほど良いとされる。
            3.  ファンクションポイント（FP）法
                FP値は「基準値×（0.65+調整値/100）」で計算され、原価は「FP値×作業単価×換算値」で計算される。
            4.  使い勝手
                画面の視認性、操作性、入力補助、互換性などが評価項目。
*   バグ発生率
        1ステップ数あたりの発生バグ数で評価されるが、追加テストを実施するとバグ発生率が高くなる場合がある。これは品質が悪いことを意味するのではなく、品質評価の1指標である。


### 第5回 WBS (2025年5月14日)
### 第6回 WBS続き (2025年5月21日)
*   WBSの定義
        プロジェクト目標を達成し、必要な要素成果物を生成するために、プロジェクトチームが実行する作業を、要素成果物を主体に階層的に要素分解したもの。プロジェクトを細かな作業（Work）に分解（Breakdown）した構成図（Structure）であり、作業を細かく分解し、作業順に並べる。
*   WBSのメリット
    *   スコープが明確になる（やらないことが明確になる）。
    *   作業を洗い出す（やるべき作業が明確になる）。
    *   全体管理と作業計画が明確化される。
    *   プロジェクト実施時はWBSに則り実行するのみとなる。
*   WBSの作り方
    *   スコープを明確にする。
    *   トップダウンアプローチ（ボトムアップではない）で行う。
    *   バックキャスティング（フォアキャスティングではない）で行う。
    *   大きな作業をグルーピングする（例: データ収集、データ分析、可視化）。
    *   グルーピングした作業の相互関連を考える（例: データ収集の後に分析）。
    *   各グループの作業をMECEで洗い出す。


### 第7回 コーディング (2025年5月28日)
コーディングにおける基本原則として、「コードは書くよりも読まれることの方が多い」ため、他人や未来の自分が読みやすいコードを書く必要性があり、そのためにはルールの遵守が不可欠である。
*    コードのレイアウトに関するガイドライン
    *    1行の長さは79文字以内（docstringやコメントは72文字以内）とする。
    *    複数行にまたがる場合は、要素を縦に揃える（Hanging indentation）。
    *    インデントは4スペースとし、タブは使用しない。
    *    スペースや改行の使い方として、演算子の前後には1スペース、無駄なスペースは避け、文を重ねないことが推奨された。
    *    import文は、標準ライブラリ → サードパーティ → ローカルアプリケーションの順で記述する。
    *    命名規則について、以下のルールが示された。
    *    パッケージ：全て小文字で短い名前。
    *    モジュール：小文字。アンダースコアで区切っても良い。
    *    クラス・例外：CapWords方式。
    *    関数・メソッド：小文字＋アンダースコアで単語を区切る。
    *    定数：大文字＋アンダースコアで単語を区切る。
    *    変数・引数：小文字＋アンダースコア。
    *    l（小文字エル）、O（大文字オー）、I（大文字アイ）は避ける。
    *    エンコーディングはUTF-8を使用し、ASCII以外の文字（例：日本語）は極力避ける。
    **Linter（静的解析ツール）**として、flake8やVSCodeのpylintが紹介された。

### 第8回 バージョン管理 (2025年6月4日)
バージョン管理は、「誰が」「いつ」「どのように」ファイルを変更したかを記録・管理する仕組みであり、共同開発を円滑に進める上で重要である。
バージョン管理システムには以下の2種類がある。
集中管理型（例：Subversion）：リモート1拠点で管理され、同時編集による衝突や通信ラグの課題がある。
分散管理型（例：Git）：各ユーザーがローカルにリポジトリを持ち、障害に強くオフライン作業にも対応可能。

*    Gitの用語と構造：
    *    リポジトリ：Gitが管理するプロジェクトフォルダ（ローカル・リモートに分かれる）。
    *    ワークツリー：実際にファイルを作成・編集する場所。
    *    ステージングエリア（index）：コミットする内容を一時的に保存する場所。

*    Gitの基本操作フロー：
    *    ファイルを作成・編集（ワークツリー）。
    *    git addでステージング。
    *    git commitで履歴として記録。
    *    git pushでリモートに反映。
    *    git pullでリモートから更新を取得。

**ブランチ（branch）**を使うことで、作業を並列に進めたり、機能ごとに管理できる。

### 第10回 Learning Git Branching / Gitコマンド (2025年6月18日)
*    Gitコマンド
    *    設定・確認系
        *    git init：初期化。
        *    git status：状態確認。
        *    git config：設定確認。
        *    git log：履歴表示。
        *    git diff：差分確認。
    *    コミット系
        *    git add：ステージング。
        *    git commit：記録。
    *    修正系
        *    git commit --amend：直前の修正。
        *    git checkout：復元。
        *    git reset：履歴巻き戻し。
        *    git revert：変更の打ち消し。
        *    git rm：削除。
    *    リモート操作系
        *    git clone：複製。
        *    git pull：取得。
        *    git push：反映。
        *    git request-pull：変更要求。
        *    git remote：接続先管理。
    *    ブランチ系
        *    git branch：作成。
        *    git checkout：切替。
        *    git merge：統合（--ff-onlyも紹介）。

### 第11回 GitHub (2025年6月25日)
GitHubは、リモートリポジトリをホストするサービスであり、オープンソース開発の中心的存在である。

GitHubの開発フロー（GitHub Flow）
*    主な機能
    *    Fork / Clone：リポジトリの複製とローカルへのコピー。
    *    Issues：課題管理（Redmineのチケットに相当）。
    *    Projects：カンバン方式での進行管理。
    *    GitHub演習では、hello-worldリポジトリを使い、チュートリアルを実施。READMEは課題用に記載。

### 第12回 CI/CD (2025年7月2日)
CI/CDの概要：
CI（継続的インテグレーション）：頻繁な統合、テスト、ビルドの自動化により、バグの早期発見と解決を促進。
CD（継続的デリバリー）：自動的にデプロイして、本番環境へ迅速に反映。

CI/CDパイプラインの流れ：
ソース変更->ビルド->テスト->デプロイ->検証->モニタリング

*    GitHub Actionsを使った実装
    *    .github/workflows/にYAMLで定義。
    *    トリガー、ジョブ、ステップ、アクションの構造。
    *    インデントはスペース、キーと値のペア、リストはハイフン。

### 第13回 CI/CDの実践：GitHub Pages (2025年7月9日)
GitHub Pagesは、リモートリポジトリからWebサイトを自動公開する機能であり、CI/CDと連携可能。
Jekyllを用いることでMarkdown → HTML変換が自動化される。


